#### 系统 cpu 调度（硬件层面的）

##### cpu三级缓存

-- 起因： 访问速度差，（常见的场景，热点数据先缓存到redis，最后固化到 db 一样道理）
-- 三级， cpu 多核心，L3 为cpu 共享 cache ，L2 为单核共享缓存，进一步 L1数据缓存和L1指令缓存。后者包含需要由CPU执行的指令，而前者用于保存将被写回到主存储器的数据。
。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/21492435/1675218894672-3b45f26e-08d8-4e20-a835-dbf93655551f.png#averageHue=%23f1e1ca&clientId=ud2913e2a-2bd8-4&from=paste&height=473&id=udfe28f57&originHeight=946&originWidth=1602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=328758&status=done&style=none&taskId=u291f19dd-b9d8-48e7-a7a7-a87500a447a&title=&width=801)

##### 线程上下文切换

- 寄存器

--CPU 内部的数量较少但是速度很快的内存

   - 指令寄存器（IR，Instruction Register），用来保存当前正在执行的一条指令。是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。
   - 通用寄存器（GR，General register）通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。通用寄存器的长度取决于机器字长，汇编语言程序员必须熟悉每个寄存器的一般用途和特殊用途，只有这样，才能在程序中做到正确、合理地使用它们。
- 程序计数器

--用于存放指令的地址。为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称，为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。

- PCB-“切换桢”

--上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。

- 上下文切换活动

-- cpu快速在多个线程，进程间切换达到并行的效果。调度的线程，进程的信息（上下文）存储PCB 中。

#### 进程，线程，协程

- 进程：

-- 并发执行的程序在执行过程中分配和管理资源的基本单位

- 线程

-- 线程是指一个进程内的执行单元，也是cpu能调度的最小的实体

- 协程

--  比线程的执行单位还好，简单理解，cpu上下文是指内核态的线程，在用户态的多个线程间进行调度，协程就是 内核态和用户态的单个线程版本，在用户态的线程内部自己维护多个任务，自己进行调度 称为协程。减少cpu切换的消耗。
-- 效率和用户态线程相近

#### 上下文：

上下文（Context）代表了程序（也可以是进程，操作系统，机器）运行时的环境和状态，联系程序整个生命周期与资源调用，是程序可以访问到的所有资源的总和，资源可以是一个变量，也可以是一个对象的引用。

#### 上下文切换

上下文切换（context switch），指的是发生进程调度（进程切换）时，内核（kernel）要把当前进程的状态和数据保存起来以备以后使用，同时把之前保存的进程的相关状态调出来，这样新调度出来的进程才能运行。

#### 原语

 一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。不可侵入的代码块，由若干条指令组成。
计算机是一门人造科学，因此真正意义上的“原语”（Primitive）是不存在的。操作系统层面上的“原语”（比如 write 之类的系统调用）对程序员来讲的确是不可分割的最小单位，但是这些系统调用本身还是用好几句汇编语句组成的（对于 Linux 来说是 C 语言）。可能有人要说到了机器代码这一级就不能再分了，但事实上一条机器指令也是由好几个组合逻辑信号构成的。同样的道理，控制信号也不过是无数电子在器件内部漂移的结果。（视角不同，对于“原语”的定义不同，不同尺度对于一个个人的评定不同。只能在相同尺度上以主观的意愿定义），因此定义“原语”的前提是观察者所处的位置（上下文）。一旦规定了观察者的位置和观察的角度，比如就在操作系统的这层上，read，write，wait这些个系统调用自然就是最“原始”的词汇，这也是为什么“原语”会在操作系统中频繁出现的缘故。
**上下文也可以被定义为一个操作被认为是原子性的界限。**

#### 竞争条件

-- 两个或多个操作必须按正确的顺序执行，而程序并未保证这个顺序，就会发生竞争条件。
大多数情况下，竞争条件会处于数据竞争中，即多个操作对单一数据进行的竞争，一个并发操作尝试读取一个变量，而在某个不确定的时间，另一个并发操作视图写入同一个变量。因为开发人员总是用顺序性的思维来思考问题，他们总假设某行代码会先于另一行代码执行。常见的基于线程通信的方式将多个并行处理的操作进行同步顺序性处理（java 中sleep wait，golang 中 time.Sleep）但是不可靠，通过显式休眠的方式只是在概率上增加了逻辑的正确性，但不会真正变成逻辑上的正确。休眠时间也会影响程序的运行效果！

#### 原子性

在它的运行环境中是不可分割或不可中断的，在所定义的上下文中，原子性的东西将完整的被运行，期间不会同时发生其他事情。原子性的定义是在指定的上下文中，确定原子性需要先确定上下文或者范围，然后考虑操作的原子性。
当一个东西是原子的，说明它在并发环境中是安全的。而大多数语句不是原子的，更不用说函数、方法和程序了，所以为了构建逻辑正确的程序，需要我们做**内存访问同步**，使用一系列操作来强制保持原子性。

#### 内存访问同步

  临界区：程序中需要独占访问共享资源的部分。(可以理解成读写共享资源的代码段)
对临界区做数据访问同步，具体做法即互斥锁。通过加锁的方式对部分的内存块空间进行锁定，保证各个临界区对共享资源（data）的独占访问权，从而对内存的访问进行了同步。但这仅仅解决了数据竞争，没有解决竞争条件 ！这种方式同步对内存的访问有性能上的问题。

##### java场景

- 高优先级的线程占用了大部分的cpu时间，低优先级线程发生饥饿

-- 线程优先级设定，cpu执行的机会与线程优先级相关

- 线程被永久堵塞在一个等待进入同步块的状态

-- java 的synchronize语句块不保证线程进入语句块的顺序，所以这就存在一个可能的问题，有一个线程一直阻塞在synchronize语句块，其他线程永远都无法进入synchronize。

- 线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象

-- 同样的，类似synchronize，notify也不保证线程被唤醒的顺序。所以也存在一个风险，就是一个wait的线程一直处于wait的状态，永远也没有被notify所唤醒。

#### 同步访问内存的平衡点

同步访问内存代价是昂贵的，所以将锁扩展到临界区外是有利的，但是会产生前面的饥饿问题。
需要在粗粒度和细粒度同步之间找到一个平衡点。
一般经验是将内存访问同步限制在关键部分，不扩展到临界区外；直到同步成为性能问题，再扩展范围。

##### java中关于处理这方面的方案

- 锁升级
- 适应性自旋
- 锁粗化
- 锁消除

#### 并发和并行

并行的"同时"是同一时刻可以多个进程在运行(处于running)，并发的"同时"是经过上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种OS欺骗用户的现象。

#### CSP

通信顺序进程。一个进程的输出应该直接流向另一个进程的输入。

#### 概念（死锁，活锁，饥饿）

- 死锁

-- 所有的并发线程持续等待

- 活锁

-- 正在主动执行并发操作的程序，但是无法继续推进程序的进行，获取到锁的执行块，内部死锁，或者异常，无法释放共享资源。

- 饥饿 

-- 在任何情况下，所有的竞争线程都无法获得执行工作所需的所有资源
通常指一个或者多个贪婪的并发进程，不公平地阻止（贪婪地抢占锁，以完成整个工作循环（通常是不必要地扩大其持有共享锁上的临界区---（人话：锁升级）））一个或多个并发进程以尽可能有效地完成工作。
饥饿也可能产生于 CPU、内存、文件句柄、数据库连接，任何必须共享的资源都是有可能产生饥饿的原因。

#### java 与 goLang 语言层面控制层级区别（上下文定义的尺度，触及系统底层的层次）主要是因为线程模型不同

- java

在系统线程和内存访问同步的层级。 
jvm 控制的是线程级别访问，多线程内部元素基于引用控制与外部内存中间中的元素   cap（可见，一致，顺序）。

- golang（控制级别不在线程级别，协程 部分）

Go语言采取了不同的路线，使用goroutine和channel代替这些概念。goroutine 把我们从必须按照并行的思考方式中解放出来，作为替代，他允许我们按照更为自然的等级对问题进行建模。Go语言的运行时自动地将goroutine 映射到系统的线程上，并为我们管理它们之间的调度（智能分配OS线程）。
--不通过共享内存进行通信，通过通信来共享内存（信号量）。在面对不同场景时，选择不同的方式。

**数据所有权**：并发程序安全就是保证同时只有一个并发上下文拥有数据的所有权，通过channel可以把数据传递给其他go程，解耦生产者和消费者。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/21492435/1675217871736-6468576a-34a8-4b5f-8baf-07d7e04d3680.png#averageHue=%239c9894&clientId=ua3b01460-d6f7-4&from=paste&height=546&id=u960450fb&originHeight=1092&originWidth=1046&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1363855&status=done&style=none&taskId=u277b39af-edfe-4548-89a9-959a45b31c0&title=&width=523)
追求简洁，尽量使用channel，并且认为goroutine的使用是没有成本的。





