**jvm**
##### 类加载器 classLoad
类在jvm内部生命周期7个阶段：加载(loading)、验证（verification）、准备（Preparation）、解析（Resolution）、初始化（init）、使用（using）、卸载（unloading）七个部分，其中前5个部分属于类加载。
加载的主要作用时间外部的.class 文件加载到 java 的方法区内。需要 jvm 完成三个动作，根据类的全限定名（包名+类名）来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构； 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
类加载器 --双亲委派机制
###### 系统自带的类加载器分为三种
启动类加载器（BootstrapClassLoader）：用来加载 java 的核心类（存放\lib）目录，或者被 -Xbootclasspath 参数所指定的路径），是用原生 c++实现的，是虚拟机本身的一部分。
扩展类加载器（ExtClassLoader）：以 java代码的形式实现的。负责加载\lib\ext 目录中，或者被java.ext.dirs系统变量所指定的路径中所有类库
应用类加载器（AppClassLoader）：它负责在 JVM启动时加载来自 java 命令的 -classpath 或者-cp 选项、java.class.path 系统属性指定的jar 包和类路径。此外还可以自定义类加载器
如果用户自定义了类加载器，则自定义类加载器都以应用类加载器作为父加载器。应用类加载的父类加载器为扩展加载器。
**双亲委派机制**要求除了顶层的类加载器之外，其他类加载器都有自己的父类加载器，不过这里的类加载器之间的父子关系一版以继承关系来维护的，通常以组合的关系来复用父加载器的代码
当一个自定以类加载器需要加载一个类时，不会直接加载，而是通过委托自己的父加载器去加载，父加载器没有的话会继续递归向上查找找不到的话反馈给子加载器，由子加载器进行加载。
##### java 解释执行和编译执行
解释执行：将jvm指令逐行翻译为本地机器码，逐行解释，逐行执行。 程序启动速度快，执行速度慢
编译执行：将class文件之间编译成本地机器码并缓存下来，cpu可以直接执行。 执行速度快，程序启动速度慢。
纯编译执行的（jRockit）、解释+编译两者混用的（HotSpot）一般用的都是后者。
参数 -Xint 要求jvm只使用解释器，-Xcomp 要求JVM优先编译执行，但是解释器仍然要在编译器无法进入的情况下介入工作。
触发 JIT编译的热点代码 ： 多次调用的方法 多次调用的循环体
###### 热点探测： 

- 基于采样的热点探测 JVM周期性的检测线程方法栈顶，进行数据采样，如果发现某些方法经常出现在栈顶则认定热点代码，实现方式很高效，但是统计结果会存在误差，出现栈顶次数多也可能是方法阻塞了。
- 基于计数器的特点探测 JVM为每个方法（甚至代码块）都维护了一个计数器，每调用一个计数器就+1，计数器超过阈值之后就会被认定为热点代码。实现方式复杂，需要为每个方法维护一个计数器，但是统计结果准确。 HotSpot是基于计数器的热点探测
###### 方法调用计数器和汇编计数器

- 方法调用计数器： 统计方法被调用的次数，Client模型下阈值为1500次，Serer模式下为10000次，阈值可以通过JVM参数 -XX:CompileThreshold 设置，默认情况下调用次数不是绝对次数，而是一段时间内的调用频率，在一定的时间段内如果调用次数不足以触发编译，次数就会进入半衰期，可以使用参数 -XX：-UseCouterDecay 来关闭热度衰减，关闭后统计的就是绝对次数了，时间长了几乎所有的代码都会被编译执行。
- 回边计数器： 统计方法中循环体代码的执行次数，在字节码中遇到控制流程向后跳转的指令即为“回边”，如 For、While 循环等，遇到一次回边指定，回边计数器就会加1，当计数超过阈值后就会触发热点代码编译，回边计数器没有半衰期，统计的是绝对次数。触发热点代码编译后，程序会继续解释执行，只有当编译工作完成之后，系统会将方法的调用入口地址写入新值，下一次再次调用才会使用已编译的版本

client 和 sever 是 jvm 的两种启动模式 只有32的系统由client 模式 
##### jvm的内存区域划分
| 堆（运行时常量池） | 对象实例，元数据 |
| --- | --- |
| 方法区 | 加载好的类放在方法区，类信息，常量静态变量 |
| 栈（JVM栈和本地方法栈） | 本地方法栈：虚拟机使用到的Native方法服务 jvm栈 字节码方法非本地方法服务 |
| 程序计数器（pc寄存器） | 线程私有，记录执行位置，保证线程间切换计数器不影响 |

一个进程存在多个线程，每个线程都有自己的栈和程序计数器，一个进程中公用一个堆和方法区。
整体执行流程：先把 java文件编译成class 文件，通过类加载器加载到方法区。线程调用方法的时候，会创建一个栈帧。读取方法区的字节码执行指令，执行指令的时候，会把执行的位置记录在程序计数器中，如果创建对象，会在堆内存中创建，方法执行完，这个栈帧就会出栈。
内存参数

| -Xss | 栈内存容量 |
| --- | --- |
| -Xms | 堆最小内存容量 |
| -Xmx | 堆最大内存容量，通常和-Xms设置一样，防止运行时扩容产生的影响 |
| -Xmm | 新生代内存容量，老年代就是堆内存-新生代内存容量 |
| -XX:SurvivorRatio=8 | 新生代还细分Eden空间、From Survivor空间、To Survivor空间，设置为8代表Eden空间：From Survivor空间：To Survivor空间=8：1：1，比如新生代有10M，那Eden空间占8M，From Survivor空间、To Survivor空间各占1M。 |

##### 内存分配
###### 栈上分配：
 将线程私有的不可能被其他线程访问的对象打算分配到栈上，而不是分配在堆上。打散分配意思是讲对象的不同属性分别分配给不同局部变量。 减少临时对象在堆内分配的数量，jvm通过逃逸分析确定该对象会不会被外部访问。如果不会逃逸可以将改对象在栈上分配内存，随栈帧出站而销毁，减少垃圾回收压力。 

   - 好处：栈上分配速度快，对象销毁不需要垃圾回收，方法执行结束后局部变量就销毁了
   - 缺点： 栈空间较小，大对象不适合在栈上分配
   - 逃逸分析： 如何判断对象是线程私有的呢，要通过逃逸分析。逃逸指的是逃出当前线程，所以逃逸对象就是可以被其他线程访问的对象，非逃逸对象就是线程私有的。 
   - 对象的逃逸分析：分析对象动态作用域，判断对象是否会逃逸到方法外，如果不会逃逸到方法外，那么久建议在堆中分配一块内存空间，用力啊存储临时的变量。是不是不会逃逸到方法外的对象就一定会分配到栈上呢？需要JVM开启逃逸分析，通过设置参数 -XX:+DoEscapeAnalysis     开启逃逸分析-XX:-DoEscapeAnalysis 关闭逃逸分析  jvm可以通过开启逃逸分析来优化对象内存分配位置，使其通过标量替换优先分配在栈上（栈上分配）jdk7之后默认开启
   - 标量替换 ： 对象通过逃逸分析确定可以在栈上分配，但是一个线程栈的空间默认为1M，栈帧空间就更小了。而内存分配需要一块连续的空间，经过计算如果这个对象可以放在栈帧上，但是栈帧的空间不是连续的，对于一个对象来说，也是不行的，因为对象需要一块连续的空间。 jvm使用标量替换的方式，在栈帧中没有一块连续的空间放下这个对象。 通过将这个对象进行进一步分解，将成员变量标记之后分解成若干部分分配到零散的空间之上。 Jdk 7之后默认开启，可以通过一下参数手动开启-XX:+EliminateAllocations
   - 标量替换和聚合量？ 标量就是不可被进一步分解的量，java的基础类型就是标量，标量的对应就是聚合量，可以被进一步分解，如java中的对象
###### 堆上分配/TLAB分配 ：
判断是否是大对象，如果是的话直接放入老年代中。如果不是的话，则判断是否是TLAB?如果是则在Eden中取分配一小块空间给线程，把这个对象放在Eden区，如果不采用TLAB的话之间放到Eden区。

   - TALB ： 本地线程分配缓存（Thred Local Allocation Buffer，TLAB）简单说，TLAB是为了避免多线程争抢内存，在每个线程初始化的时候，就在堆空间中为线程分配一块专属的内存。自己线程的对象就往自己专属的那块内存中存放即可，这样多个线程就不会取哄抢同一块内存了。jdk默认使用的是TLAB的方式分配内存。-XX:+UseTLAB 设定是否开启TLAB-XX:TLABSize 指定TLAB大小
   - Eden区对象分配	Eden 区满之后会触发 Gc 
   - 对象动态年龄判断：当前存放对象的Survivor区域里（其中一块区域，放对象的那块s区），一批对象的总大小大于这块Survivor区域内存大小的50%（-XX:TargetSurvivorRatio可以指定）那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，不需要等待年龄到了。对象动态年龄判断机制一般是 minor gc 之后触发的
   - 老年代空间分配担保机制： 
      - 年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间。如果这个可用空间小于年轻代里现有的所有对象大小之和（包括垃圾对象）就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了，如果有这个参数，就会看看老年嗲的可用内存大小，时候大于之前每一次minor gc 后进入老年代的对象的平均大小。
      - 如果上一步结果是小于或者之前说的参数没有设置的话，那么就会直接触发一下Full GC，然后触发Minor GC，如果回收完还是没有足够的空间存放新的对象就会发生’OOM‘
      - 如果minor gc 之后剩余存活的需要挪动到老年代的对象大小还是大于老年代的可用空间，那么也会触发full GC，Full GC完之后还是没有足够空间存放新的存活对象的话，发生“oom”担保机制，就是在触发Minor GC的时候，进行了一个条件判断，预估老年代空间是否能够放的下新生代的对象，如果能放的下，那么直接触发Minor GC，如果放不下，那么先触发Full GC。在触发Full GC的时候设置了担保参数会增加异步判断，而不是直接触发Full GC。判断老年代剩余可用空间 是否小于 历史每次Minor GC后进入老年代对象的平均值。这样的判断可以减少Full GC的次数。因为新生代在触发Full GC以后是会回收一部分内存的，剩余部分再放入老年代，可能就能放下了。
###### 大对象直接进入老年代

   - 什么是大对象： 
      - eden区放不下的可定是大对象
      - 通过参数设置-XX:PretenureSizeThreshold=1000000 (单位是字节) -XX:+UseSerialGC。如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。
      - 长期存活的对象进入老年代。虚拟机采用分代收集的思想来管理内存，虚拟机会给每个对象设置一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC 后仍然存活，并且能被Survivor容纳的话，将会被移动到 Survivor 空间中，并将对象年龄设为1。对象在Survivor中每熬过一次MinorGC，年龄加增加1，当它年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。
   - 将大对象直接放入老年代：避免为大对象分配内存时的复制操作而降低效率。
   - 什么情况要手动设置分代年龄： 如果我的系统里80%的对象都是有用的对象，那么经过15次GC后会在Survivor中来回翻转，这时候不如就将分代年龄设置为5或者8，这样减少在Survivor中来回翻转的次数，直接放入到老年代，节省了年轻代的空间。
   - 如何判断类是否无用：方法区主要回收的是无用的类，那么如何判断一个类是无用的类？
      - 该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例
      - 加载该类的ClassLoader已经被回收：只有可能自定义类加载器才会被回收，基于双亲委派机制applicationClassLoader 、ExtClassLoader和BootStapClassLoader是不可能被回收的
      - 该类对应的。clss没有在任何地方被引用，
##### 垃圾回收算法
###### 	算法

   - 标记-清除算法 
      - 执行步骤：标记：遍历内存区域，对需要回收的对象打上标记 随后进行清除： 再次遍历内存将已经标记过的内存进行回收
      - 缺点： 效率问题遍历了两次内存空间（第一次标记，第二次清除）空间问题：容易产生大量的内存碎片，当再需要一块比较大的内存时候，无法找到一块满足需求的，因而不得不再次进行GC
   - 复制算法 
      - 执行步骤： 将内存划分为等大的两块，每次只使用其中的一块。当一块用完之后，触发GC时，将该块中存活的对象复制到另一块区域，然后一次性清理掉这块没有用的内存。下次触发GC时将那块存活的又复制到这块，然后抹掉那块，循环往复
      - 优点： 相对于标记-清理算法解决了内存碎片化的问题。 效率更高（清理内存是，记住首尾地址，一次性抹掉）
      - 缺点：内存利用率不高，每次只能使用一版内存
      - 优化：新生代中的对象生命周期比较短而且对象活的越久越难被回收。在发生GC时，需要回收的对象特别多，存活的特别少，因此需要搬移到另一块内存的对象非常少，所以不需要1:1的划分空间，而是将整个新生代按照8:1:1进行分配，最大的为Eden，较小的两块为To Survivor和From Survivor 	首次GC时，只需要将Eden存活的对象复制到To。然后将Eden区整体回收。再次GC时，将Eden和To存活的复制到From，循环往复这个过程。这样每次新生代中可用的内存就占整个新生代的90%，大大提高了内存利用率。	但不能保证每次存活的对象就永远少于新生代整体的10%，此时复制过去是存不下的，因此这里会用到另一块内存，称为老年代，进行分配担保，将对象存储到老年代。若还不够，就会抛出OOM。老年代：存放新生代中经过多次回收仍然存活的对象（默认15次）。
   - 标记-整理算法
      - 执行步骤：标记：对需要回收的进行标记，整理：让存活的对象，想内存的一端移动，然后直接清理没有用的内存

SUN jdk 
###### 垃圾回收器

- CMS 基于标记-清除算法实现
   - 步骤
      1. 初始标记-短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
      2. 并发标记-和用户的应用程序同时进行，进行GC Roots追踪的过程，标记从GC Roots开始关联的对象开始遍历整个可达分析路径的对象，这个时间较长，所以采用并发处理（垃圾回收器与用户线程同时工作）
      3. 重新标记-短暂，修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一点，但远比并发标记的事件短并发清除 由整个过程耗时最长的并发标记和并发清除过程都可以和用户线程一起工作，所以,从总体上来说,CMS 收集器的内存回收过程是与用户线程一起并发执行的-XX:+UseConcMarkSweepGC ，表示新生代使用 ParNew，老年代的用 CMS
   - CMS 中的问题
      - cpu敏感： CMS对于处理器资源敏感，毕竟采用了并发的收集，当核心处理器不足4个时，CMS对用户的影响比较大
      - 浮动垃圾：由于CMS并发清理阶段用户线程还在原型，伴随程序运行自然还会产生新的垃圾，这一部分垃圾在标记过程之后，CMS无法在档次收集中处理他们，只能留到下一次进行处理，这部分称为“浮动垃圾’，由于浮动垃圾的存在，因此需要预留出一部分内存，以为这CMS收集不能像其他收集器那样等待老年带快慢的时候进行回收，在1.6的版本中老年代空间使用率阈值(92%)如果预留的内存不够存放浮动垃圾,就会出现Concurrent Mode Failure,这时虚拟机将临时启用Serial Old来代替 CMS.
      - 会产生空间碎片：标记清除算法会导致产生不连续的空间碎片。但是最大的问题是CMS采用了标记清除算法,所以会有内存碎片,当碎片较多时,给大对象的分配带来很大的麻烦,为了解决这个问题,CMS提供一个参数:-XX:+UseCMSCompactAtFullCollection，一般是开启的，如果分配不了大对象，就进行内存碎片的整理过程。 这个地方一般会使用Serial Old,因为Serial Old是一个单线程,所以如果内存空间很大,且对象较多时,CMS发生这样情况会很卡
      - 总结： 问题比较多目前没有默认的是使用CMS的，只能手工指定。
      - 为什么CMS采用标记-清除 在实现并发的垃圾回收时,如果采用标记整理算法,那么还涉及到对象的移动(对象的移动必定涉及到引用的变化,这个需要暂停业务线程来处理栈信息,这样使得并发收集的暂停时间更长),所以使用简单的标记-清除算法才可以降低CMS的STW时间 该垃圾回收器适合回收堆空间几个G~200G左右. 在JDK1.8中,配置参数: -XX:+UseConcMarkSweepGC 为老年代启用 CMS 垃圾收集器。当吞吐量 ( -XX:+UseParallelGC) 垃圾收集器无法满足应用程序延迟要求时，Oracle 建议您使用 CMS 垃圾收集器。G1 垃圾收集器 ( -XX:+UseG1GC) 是另一种选择。 默认情况下，此选项处于禁用状态，并根据机器的配置和 JVM 的类型自动选择收集器。当启用该选项时，-XX:+UseParNewGC选项将自动设置，你不应该禁用它，因为下面的选项组合已经在JDK 8被弃用：-XX:+UseConcMarkSweepGC -XX:-UseParNewGC。
   - G1
      - 设计思想：swt时间不可测，G1将堆内存"化整为零",将堆内存划分成多个大小相等独立区域(Region),每一个Region都可以根据需要,扮演新生代的Eden空间,Survivor空间,或者老年代空间.回收器能够对扮演不同角色的Region采用不同的策略去处理,这样无论是新创建的对象还是已经存活了一段时间,熬过多次收集的旧对象都能获取很好的收集效果.
      - RegionRegion可能是Eden,也有可能是Survivor,也有可能是Old,另外Region中还有一类特殊的Humongous区域,专门用来存储大对象. G1 认为只要大小超过了一个Region 容量一半的对象即可判定为大对象. 每个Region的大小可以通过参数-XX:G1HeapRegionSize 设定,取值范围为 1MB~32MB,且应为2的N次幂.而对于哪些超过了整个Region 容量的超级大对象,将会被存放在 N 个连续的 Humongous Region之中,G1的进行回收大多数情况下都把Humongous Region 作为老年代的一部分来进行看待.
      - 运行过程
         1. 初始标记： 只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发执行是，能正确地在可用Region中分配新对象，这个阶段需要停顿线程，但耗时很短，而且是借用Minor GC的时候同步完成的，所以G1收集器在这个阶段没有额外的停顿；TAMS：GC与用户线程并发进行，解决回收过程中新对象的分配标识，有这个标志将不纳入垃圾回收范围
         2. 并发标记：从GC Root 开始对堆中对象进行可达性分析,递归扫描整个堆里的对象图,找出要回收的对象,这阶段耗时较长,但可与用户程序并发执行.当对象图扫描完成以后,并发时有引用变动的对象,这些对象会漏标(后续再讲三色标记的时候回细讲这个问题),漏标的对象会被一个叫做SATB(snapshot-at-the-beginning)算法来解决
         3. 最终标记：对用户线程做另一个短暂的暂停,用于处理并发阶段结后仍遗留下来的最后那少量的SATB记录(漏标对象).
         4. 筛选回收：负责更新Region的统计数据,对各个Region的回收价值和成本进行排序,根据用户所期望的停顿时间来指定回收计划,可以自由选择任意多个Region构成回手集,然后把决定回收的那一部分Region的存活对象复制到空的Region中,在清理掉整个旧Region的全部空间.这里的操作涉及存活对象的移动,是必须暂停用户线程,由多条收集器线程并行完成的.
      - 特点：
         - 并行与并发：G1能充分利用多CPU，多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间,部分其他收集器原本需要停顿Java线程执行的GC动作,G1收集器仍然可以通过并发的方式让Java程序继续执行
         - 分代收集：与其他收集器一样,分代概念在G1中依然得以保留.虽然G1可以不需要其他收集器配合就能独立管理整个GC堆,但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间,熬过多次GC的旧对象以获取更好的收集效果.
         - 空间整合：与CMS的"标记-清理"算法不同,G1从整体来看是基于"标记整理"算法实现的收集器,从局部(两个Region之间)上来看是基于"复制"算法来实现的,但无论如何,这两种算法都意味着G1运作期间不会产生内存空间碎片,收集后能提供规整的可用内存.这种特性有利于程序长时间运行,分配大对象时不会因为无法找到连续内存空间而提取触发下一次GC.
         - 停顿时间：-XX:MaxGCPauseMillis 指定目标的最大停顿时间，G1 尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间。
      - 选取 ：该垃圾回收器适合回收堆空间上百 G。一般在 G1 和 CMS 中间选择的话平衡点在 6~8G，只有内存比较大 G1 才能发挥优势 （一般用不到，除非土豪）
##### 内存状态分析工具
	使用场景：内存溢出”OOM“， 内存泄露，线程死锁，锁争用， JAVA进程消耗CPU过高。这些场景出现常常通过重启服务器，增大内存处理，实际情况，需要还原当时的业务场景，分析内存，线程等数据，涉及到性能分析共计

- Jconsole:jdk 自带，功能简单，但是可以在系统有一定负载的情况下使用，对垃圾回收算法有很详细的追踪
- JProfuker ; 商业软件功能强大
- VisualIVM：JDK自带，功能强大，与JProfuker类似
- MAT：基于Eclipse的内存分析工具
##### 线程资源同步和交互机制

- 线程资源同步
   - 线程资源执行机制
      1. 	同一个线程上的操作一定是顺序执行的额
      2. 对于main memory上同一个变量的操作一定是按顺序的，也就是不可能两个请求同时读取变量值
      3. 对于加了锁的main memory对象上的操作一定是顺序执行的
   - 线程资源同步机制
      - synchronized实现：synchronized除了可以直接写在方法上，还可以写在对象上，区别仅仅在于JVM会根据这些情况lock标记是打在什么上。需要注意的是，如果使用syncronized修饰静态方法时，锁的粒度是整个类。
      - lock/unlock：lock/unlock机制原理和synchronized相同，他们都可以保证某段代码执行的原子性。由于锁会阻断其他线程需要同样锁的部分执行，因此要注意避免死锁的情况
- 线程交互机制线程之间除了会产生资源的竞争外，还会有交互的需求。例如最典型的连接池，连接池中通常都会有get个return方法，return方法的时候需要将连接返回到缓存列表中，并将可使用的连接数+1，而在get方法的时候在判断可使用的连接数已经到0以后，需要进入一个等待状态，当有连接返回到连接池时，应该通知下get方法，不需要再等待了。如果没有这个交互机制，就只能在get方法中不断轮询判读可使用的连接数。 JVM提供了wait/notify/notifiAll方式来支持这类需求
- 线程状态分析也有很多工具，比如java自带的jstack linux系统中使用kill -3 [pid] 有JConsole等。
